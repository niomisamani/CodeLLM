# 1. Function to add two user-provided numbers and return the sum.
def add_numbers(a, b):
    return a + b

# 2. Find and print the largest among three numbers.
def largest_of_three(a, b, c):
    return max(a, b, c)

# 3. Find and print the smallest among three numbers.
def smallest_of_three(a, b, c):
    return min(a, b, c)

# 4. Merge two given lists into one.
def merge_lists(list1, list2):
    return list1 + list2

# 5. Check whether a number is prime or not.
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# 6. Print the factors of a given number.
def factors(n):
    return [i for i in range(1, n + 1) if n % i == 0]

# 7. Find the factorial of a number.
def factorial(n):
    return 1 if n == 0 else n * factorial(n - 1)

# 8. Determine whether a number is negative, positive, or zero.
def check_sign(n):
    if n > 0:
        return 'Positive'
    elif n < 0:
        return 'Negative'
    else:
        return 'Zero'

# 9. Print the multiplication table of a given number.
def multiplication_table(n):
    return [n * i for i in range(1, 11)]

# 10. Print powers of 2 for a given number of terms.
def powers_of_two(n):
    return [2 ** i for i in range(n)]

# 11. Filter numbers in a list divisible by a given number.
def divisible_by(lst, num):
    return [x for x in lst if x % num == 0]

# 12. Return the sum of N natural numbers.
def sum_natural_numbers(n):
    return n * (n + 1) // 2

# 13. Swap the first and last elements in a list.
def swap_first_last(lst):
    if len(lst) > 1:
        lst[0], lst[-1] = lst[-1], lst[0]
    return lst

# 14. Find the area of a circle given the radius.
import math
def area_of_circle(radius):
    return math.pi * radius * radius

# 15. Print the sum of squares of the first N natural numbers.
def sum_of_squares(n):
    return sum(i ** 2 for i in range(1, n + 1))

# 16. Print the length of a list.
def list_length(lst):
    return len(lst)

# 17. Print the length of a given tuple.
def tuple_length(tpl):
    return len(tpl)

# 18. Print elements of a list, one element per line.
def print_elements(lst):
    for elem in lst:
        print(elem)

# 19. Remove all odd numbers from a list.
def remove_odds(lst):
    return [x for x in lst if x % 2 == 0]

# 20. Remove all even numbers from a list.
def remove_evens(lst):
    return [x for x in lst if x % 2 != 0]

# 21. Find LCM of two numbers.
import math
def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

# 22. Check whether a number is a palindrome.
def is_palindrome(n):
    return str(n) == str(n)[::-1]

# 23. Function to add and multiply using lambda functions.
add = lambda x, y: x + y
multiply = lambda x, y: x * y

# 24. Convert lowercase string to uppercase.
def to_uppercase(s):
    return s.upper()

# 25. Check if a given number is odd or even.
def is_even(n):
    return n % 2 == 0

# 26. Extract and print digits in reverse order.
def reverse_digits(n):
    return int(str(n)[::-1])

# 27. Calculate the volume of a cylinder.
def cylinder_volume(radius, height):
    return math.pi * radius ** 2 * height

# 28. Calculate BMI and provide comments.
def calculate_bmi(weight, height):
    bmi = weight / (height ** 2)
    if bmi < 18.5:
        return 'Underweight'
    elif 18.5 <= bmi < 24.9:
        return 'Normal weight'
    elif 25 <= bmi < 29.9:
        return 'Overweight'
    else:
        return 'Obese'

# 29. Explain the zip function in Python.
def explain_zip():
    return 'The zip function in Python is used to combine two or more iterables into a single iterator of tuples.'

# 30. Add two lists using Python's zip method.
def add_lists_zip(list1, list2):
    return [a + b for a, b in zip(list1, list2)]

# 31. Function to calculate the kinetic energy of an object.
def kinetic_energy(mass, velocity):
    return 0.5 * mass * velocity ** 2

# 32. Function to find the area of a right-angle triangle.
def area_of_right_triangle(base, height):
    return 0.5 * base * height

# 33. Find the area of a triangle using Heron's formula.
def area_heron(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5

# 34. Function to calculate speed, distance, and time.
def calculate_speed(distance, time):
    return distance / time

# 35. Function to merge two dictionaries.
def merge_dictionaries(dict1, dict2):
    return {**dict1, **dict2}

# 36. Function to find the GCD of two numbers.
import math
def gcd(a, b):
    return math.gcd(a, b)

# 37. Function to calculate power using recursion.
def power_recursive(base, exponent):
    if exponent == 0:
        return 1
    return base * power_recursive(base, exponent - 1)

# 38. Function to remove duplicate items from a list.
def remove_duplicates(lst):
    return list(set(lst))

# 39. Write a decorator function to track the time taken by a function.
import time
def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f'Time taken: {end_time - start_time} seconds')
        return result
    return wrapper

# 40. Function to calculate gravitational force.
def gravitational_force(m1, m2, distance):
    G = 6.67430e-11
    return G * m1 * m2 / distance ** 2

# 41. Implementing Pigeonhole Sort.
def pigeonhole_sort(arr):
    min_val, max_val = min(arr), max(arr)
    size = max_val - min_val + 1
    holes = [[] for _ in range(size)]
    for x in arr:
        holes[x - min_val].append(x)
    return [x for hole in holes for x in hole]

# 42. Convert time from 12-hour to 24-hour format.
def convert_to_24hr(time_str):
    from datetime import datetime
    return datetime.strptime(time_str, '%I:%M %p').strftime('%H:%M')

# 43. Implement a generator function to generate Fibonacci numbers.
def fibonacci_generator():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 44. Function to remove punctuation from a string.
import string
def remove_punctuation(text):
    return text.translate(str.maketrans('', '', string.punctuation))

# 45. Explain lambda function usage.
def explain_lambda():
    return 'Lambda functions in Python are small anonymous functions that are defined with the lambda keyword.'

# 46. Implementing Gnome Sort.
def gnome_sort(arr):
    i = 0
    while i < len(arr):
        if i == 0 or arr[i] >= arr[i - 1]:
            i += 1
        else:
            arr[i], arr[i - 1] = arr[i - 1], arr[i]
            i -= 1
    return arr

# 47. Implementing Stooge Sort.
def stooge_sort(arr, l=0, h=None):
    if h is None:
        h = len(arr) - 1
    if arr[l] > arr[h]:
        arr[l], arr[h] = arr[h], arr[l]
    if h - l + 1 > 2:
        t = (h - l + 1) // 3
        stooge_sort(arr, l, h - t)
        stooge_sort(arr, l + t, h)
        stooge_sort(arr, l, h - t)
    return arr

# 48. Count the number of times a function is called.
def count_calls(func):
    def wrapper(*args, **kwargs):
        wrapper.calls += 1
        return func(*args, **kwargs)
    wrapper.calls = 0
    return wrapper

# 49. Calculate the moment of inertia of a ring or sphere.
def moment_of_inertia(mass, radius, shape='ring'):
    if shape == 'ring':
        return mass * radius ** 2
    elif shape == 'sphere':
        return (2/5) * mass * radius ** 2
    else:
        raise ValueError('Shape not supported')

# 50. Print a list in reverse order.
def print_reverse(lst):
    for elem in reversed(lst):
        print(elem)

# 51. Explain global and local scope.
def explain_scope():
    return 'Global scope is accessible throughout the code, while local scope is restricted to the function where it is defined.'

# 52. Use map to square a list of numbers.
def square_list(lst):
    return list(map(lambda x: x**2, lst))

# 53. Function to calculate angular velocity.
def angular_velocity(radius, linear_velocity):
    return linear_velocity / radius

# 54. Function to find the area of a sphere or hemisphere.
def area_of_sphere(radius, is_hemisphere=False):
    if is_hemisphere:
        return 2 * math.pi * radius ** 2
    return 4 * math.pi * radius ** 2

# 55. Function to find roots of a quadratic equation.
def quadratic_roots(a, b, c):
    discriminant = b ** 2 - 4 * a * c
    if discriminant >= 0:
        root1 = (-b + discriminant ** 0.5) / (2 * a)
        root2 = (-b - discriminant ** 0.5) / (2 * a)
        return root1, root2
    return 'Complex roots'

# 56. Function to calculate the electrostatic force between two charges.
def electrostatic_force(q1, q2, distance):
    k = 8.9875e9
    return k * q1 * q2 / distance ** 2

# 57. Function to calculate and return compound interest.
def compound_interest(principal, rate, time, n=1):
    return principal * (1 + rate / (100 * n)) ** (n * time)

# 58. Convert temperature from Celsius to Fahrenheit.
def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32

# 59. Calculate the area and perimeter of basic geometric shapes.
def area_and_perimeter(shape, *args):
    if shape == 'rectangle':
        length, width = args
        return length * width, 2 * (length + width)
    elif shape == 'circle':
        radius = args[0]
        return math.pi * radius ** 2, 2 * math.pi * radius

# 60. Explain the use of Pythonâ€™s assert.
def explain_assert():
    return 'Assert is used for debugging purposes to test if a condition is true.'

# 61. Function to convert list elements to uppercase.
def to_uppercase_list(lst):
    return [x.upper() for x in lst]

# 62. Function to print unique elements in a list.
def unique_elements(lst):
    return list(set(lst))

# 63. Function to print ASCII values of characters.
def ascii_values(s):
    return {char: ord(char) for char in s}

# 64. Filter list elements using a substring.
def filter_by_substring(lst, substring):
    return [s for s in lst if substring in s]

# 65. Recursive function to print Fibonacci numbers.
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

# 66. Function to return the cartesian distance between two points.
def cartesian_distance(x1, y1, x2, y2):
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

# 67. Calculate pressure, volume, and temperature using the ideal gas equation.
def ideal_gas_law(P=None, V=None, n=None, T=None, R=0.0821):
    if P is None:
        return (n * R * T) / V
    if V is None:
        return (n * R * T) / P
    if n is None:
        return (P * V) / (R * T)
    if T is None:
        return (P * V) / (n * R)

# 68. Function to return the sum of first n natural numbers.
def sum_natural(n):
    return n * (n + 1) // 2

# 69. Function to print even numbers from a list using list comprehension.
def filter_even(lst):
    return [x for x in lst if x % 2 == 0]

# 70. Function to print odd numbers from a list using list comprehension.
def filter_odd(lst):
    return [x for x in lst if x % 2 != 0]

# 71. Use list comprehension to create a new list with numbers greater than a given number.
def greater_than(lst, num):
    return [x for x in lst if x > num]

# 72. Function to find the product of a list.
import math
def product_of_list(lst):
    return math.prod(lst)

# 73. Function to calculate factorial using recursion.
def factorial_recursive(n):
    return 1 if n == 0 else n * factorial_recursive(n - 1)

# 74. Function to count vowels in a string.
def count_vowels(s):
    return sum(1 for char in s.lower() if char in 'aeiou')

# 75. Function to find the number of occurrences of a character in a string.
def char_occurrences(s, char):
    return s.count(char)

# 76. Implementing selection sort.
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 77. Function to remove all vowels from a given string.
def remove_vowels(s):
    return ''.join(char for char in s if char.lower() not in 'aeiou')

# 78. Implementing bubble sort.
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 79. Implementing insertion sort.
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# 80. Function to reverse a string using slicing.
def reverse_string_slicing(s):
    return s[::-1]

# 81. Function to reverse a string using a loop.
def reverse_string_loop(s):
    reversed_str = ''
    for char in s:
        reversed_str = char + reversed_str
    return reversed_str

# 82. Function to check whether a word is a palindrome or not.
def is_palindrome_word(word):
    return word == word[::-1]

# 83. Function to calculate simple interest.
def simple_interest(principal, rate, time):
    return (principal * rate * time) / 100

# 84. Function to remove whitespace from a string.
def remove_whitespace(s):
    return ''.join(s.split())

# 85. Count the number of words in a string.
def word_count(s):
    return len(s.split())

# 86. Implementing quicksort.
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)

# 87. Function to sort a dictionary by values.
def sort_dict_by_values(d):
    return dict(sorted(d.items(), key=lambda item: item[1]))

# 88. Calculate the sum of squares of first n odd numbers.
def sum_squares_of_odds(n):
    return sum(i ** 2 for i in range(1, 2 * n, 2))

# 89. Find common elements between two lists.
def common_elements(list1, list2):
    return list(set(list1) & set(list2))

# 90. Find unique elements in both given lists.
def unique_elements_both_lists(list1, list2):
    return list(set(list1) ^ set(list2))

# 91. Check if two strings are anagrams.
def are_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)

# 92. Implementing merge sort.
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]

        merge_sort(L)
        merge_sort(R)

        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

    return arr

# 93. Remove duplicates from a sorted list.
def remove_duplicates_sorted(lst):
    return list(dict.fromkeys(lst))

# 94. Implementing heapsort.
import heapq
def heapsort(arr):
    heapq.heapify(arr)
    return [heapq.heappop(arr) for _ in range(len(arr))]

# 95. Function to capitalize the first letter of each word in a string.
def capitalize_words(s):
    return s.title()

# 96. Implementing counting sort.
def counting_sort(arr):
    max_val = max(arr) + 1
    count = [0] * max_val
    for num in arr:
        count[num] += 1
    output = []
    for i, freq in enumerate(count):
        output.extend([i] * freq)
    return output

# 97. Print all prime numbers in a given range.
def primes_in_range(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, int(num ** 0.5) + 1):
                if num % i == 0:
                    break
            else:
                primes.append(num)
    return primes

# 98. Implementing radix sort.
def radix_sort(arr):
    max_val = max(arr)
    exp = 1
    while max_val // exp > 0:
        counting_sort_exp(arr, exp)
        exp *= 10
    return arr

# 99. Swap two numbers without using a third variable.
def swap_numbers(a, b):
    a, b = b, a
    return a, b

# 100. Function to calculate the power of a number using iterative method.
def power_iterative(base, exponent):
    result = 1
    while exponent > 0:
        result *= base
        exponent -= 1
    return result

# 101. Convert decimal to binary, octal, and hexadecimal.
def convert_bases(n):
    return bin(n), oct(n), hex(n)

# 102. Check if a character is a vowel or consonant.
def is_vowel(char):
    return char.lower() in 'aeiou'

# 103. Sum the digits of an integer.
def sum_of_digits(n):
    return sum(int(digit) for digit in str(n))

# 104. Function to compute the power of a number using **.
def power_using_operator(base, exponent):
    return base ** exponent

# 105. Convert a string to title case.
def to_title_case(s):
    return s.title()

# 106. Implementing shell sort.
def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2
    return arr

# 107. Find the HCF (highest common factor) of two numbers.
def hcf(a, b):
    while b:
        a, b = b, a % b
    return a

# 108. Find the LCM (lowest common multiple) of two numbers.
def lcm(a, b):
    return abs(a * b) // hcf(a, b)

# 109. Find the ASCII value of a character.
def ascii_value(char):
    return ord(char)

# 110. Find the number of words that start with a vowel in a sentence.
def words_starting_with_vowel(sentence):
    return sum(1 for word in sentence.split() if word[0].lower() in 'aeiou')

# 111. Check if a given year is a leap year.
def is_leap_year(year):
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

# 112. Implementing binary search.
def binary_search(arr, x):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1

# 113. Count the frequency of a word in a sentence.
def word_frequency(sentence, word):
    return sentence.lower().split().count(word.lower())

# 114. Find all the divisors of a given number.
def divisors(n):
    return [i for i in range(1, n + 1) if n % i == 0]

# 115. Function to convert kilometers to miles.
def km_to_miles(km):
    return km * 0.621371

# 116. Function to convert pounds to kilograms.
def pounds_to_kg(pounds):
    return pounds * 0.453592

# 117. Function to calculate the area of a trapezoid.
def area_of_trapezoid(a, b, height):
    return 0.5 * (a + b) * height

# 118. Implementing cocktail shaker sort.
def cocktail_shaker_sort(arr):
    swapped = True
    start = 0
    end = len(arr) - 1
    while swapped:
        swapped = False
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        if not swapped:
            break
        swapped = False
        end -= 1
        for i in range(end - 1, start - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        start += 1
    return arr

# 119. Function to calculate the perimeter of a rectangle.
def perimeter_of_rectangle(length, width):
    return 2 * (length + width)

# 120. Implementing bucket sort.
def bucket_sort(arr):
    largest = max(arr)
    length = len(arr)
    size = largest / length
    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(arr[i] / size)
        if j != length:
            buckets[j].append(arr[i])
        else:
            buckets[length - 1].append(arr[i])
    for i in range(length):
        buckets[i] = sorted(buckets[i])
    result = []
    for i in range(length):
        result = result + buckets[i]
    return result

# 121. Find the sum of elements in an array.
def sum_of_array(arr):
    return sum(arr)

# 122. Implementing pancake sort.
def pancake_sort(arr):
    for curr_size in range(len(arr), 1, -1):
        mi = arr.index(max(arr[:curr_size]))
        arr = arr[:mi + 1][::-1] + arr[mi + 1:]
        arr = arr[:curr_size][::-1] + arr[curr_size:]
    return arr

# 123. Reverse a given number using mathematical manipulation.
def reverse_number(n):
    reversed_num = 0
    while n > 0:
        reversed_num = reversed_num * 10 + n % 10
        n //= 10
    return reversed_num

# 124. Calculate the number of trailing zeroes in a factorial.
def trailing_zeroes_in_factorial(n):
    count = 0
    i = 5
    while n // i > 0:
        count += n // i
        i *= 5
    return count

# 125. Function to calculate the slope of a line given two points.
def slope_of_line(x1, y1, x2, y2):
    return (y2 - y1) / (x2 - x1) if x1 != x2 else 'Undefined'

# 143. Implementing tree sort.
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(root, value):
    if root is None:
        return TreeNode(value)
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)
    return root

def inorder_traversal(root, result=[]):
    if root:
        inorder_traversal(root.left, result)
        result.append(root.value)
        inorder_traversal(root.right, result)
    return result

def tree_sort(arr):
    root = None
    for value in arr:
        root = insert(root, value)
    return inorder_traversal(root)

# 144. Find the determinant of a matrix.
import numpy as np
def determinant(matrix):
    return round(np.linalg.det(np.array(matrix)), 2)

# 145. Count the number of unique words in a sentence.
def unique_word_count(sentence):
    return len(set(sentence.lower().split()))

# 146. Sort a list of dictionaries by a given key.
def sort_dicts(dicts, key):
    return sorted(dicts, key=lambda x: x[key])

# 147. Find the standard deviation of a list of numbers.
import statistics
def standard_deviation(numbers):
    return statistics.stdev(numbers)

# 148. Convert a string representation of a list into an actual list.
def str_to_list(s):
    return eval(s)

# 149. Check if a string contains only digits.
def contains_only_digits(s):
    return s.isdigit()

# 150. Split a string based on a delimiter without using split().
def custom_split(s, delimiter):
    result, temp = [], ''
    for char in s:
        if char == delimiter:
            result.append(temp)
            temp = ''
        else:
            temp += char
    result.append(temp)
    return result

# 151. Convert a list of characters into a string.
def list_to_string(lst):
    return ''.join(lst)

# 152. Implementing balanced parentheses check.
def balanced_parentheses(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack

# 153. Find the sum of digits of a given number using recursion.
def sum_of_digits_recursive(n):
    return n if n < 10 else n % 10 + sum_of_digits_recursive(n // 10)

# 154. Implementing queue using two stacks.
class QueueUsingStacks:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def enqueue(self, item):
        self.stack1.append(item)

    def dequeue(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop() if self.stack2 else 'Queue is empty'

# 155. Calculate compound interest.
def compound_interest(principal, rate, time, n=1):
    return principal * ((1 + rate / (100 * n)) ** (n * time))

# 156. Find the sum of an arithmetic progression.
def sum_of_arithmetic(a, d, n):
    return n * (2 * a + (n - 1) * d) // 2

# 157. Implement stack using queues.
from queue import Queue
class StackUsingQueues:
    def __init__(self):
        self.q1 = Queue()
        self.q2 = Queue()

    def push(self, item):
        self.q2.put(item)
        while not self.q1.empty():
            self.q2.put(self.q1.get())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self):
        return self.q1.get() if not self.q1.empty() else 'Stack is empty'

# 158. Implement a function to find missing numbers in an array.
def find_missing_numbers(arr):
    return sorted(set(range(min(arr), max(arr) + 1)) - set(arr))

# 159. Implementing a circular queue.
class CircularQueue:
    def __init__(self, size):
        self.queue = [None] * size
        self.size = size
        self.front = self.rear = -1

    def enqueue(self, item):
        if (self.rear + 1) % self.size == self.front:
            return 'Queue is full'
        elif self.front == -1:
            self.front = self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = item

    def dequeue(self):
        if self.front == -1:
            return 'Queue is empty'
        elif self.front == self.rear:
            item = self.queue[self.front]
            self.front = self.rear = -1
        else:
            item = self.queue[self.front]
            self.front = (self.front + 1) % self.size
        return item

# 160. Calculate the median of a list of numbers.
def median_of_list(lst):
    lst.sort()
    n = len(lst)
    if n % 2 == 1:
        return lst[n // 2]
    else:
        return (lst[n // 2 - 1] + lst[n // 2]) / 2

# 161. Find the maximum and minimum numbers in a list without using built-in functions.
def max_min(lst):
    max_val = min_val = lst[0]
    for num in lst[1:]:
        if num > max_val:
            max_val = num
        elif num < min_val:
            min_val = num
    return max_val, min_val

# 162. Find the square root of a number without using math.sqrt.
def square_root(n):
    x = n
    y = 1
    e = 0.000001
    while x - y > e:
        x = (x + y) / 2
        y = n / x
    return x

# 163. Function to merge two sorted arrays.
def merge_sorted_arrays(arr1, arr2):
    merged = []
    i = j = 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1
    merged.extend(arr1[i:])
    merged.extend(arr2[j:])
    return merged

# 164. Calculate the angle between the hour and minute hand of a clock.
def clock_angle(hour, minute):
    if hour < 0 or minute < 0 or hour > 12 or minute > 60:
        return 'Invalid input'
    if hour == 12:
        hour = 0
    if minute == 60:
        minute = 0
    hour_angle = 0.5 * (hour * 60 + minute)
    minute_angle = 6 * minute
    angle = abs(hour_angle - minute_angle)
    return min(360 - angle, angle)

# 165. Count the number of leaf nodes in a binary tree.
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def count_leaf_nodes(root):
    if not root:
        return 0
    if not root.left and not root.right:
        return 1
    return count_leaf_nodes(root.left) + count_leaf_nodes(root.right)

# 166. Find the second largest number in a list.
def second_largest(lst):
    first = second = float('-inf')
    for num in lst:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second

# 167. Convert Roman numerals to integers.
def roman_to_integer(roman):
    roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in roman[::-1]:
        value = roman_dict[char]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value
    return total

# 168. Find the longest palindrome in a given string.
def longest_palindromic_substring(s):
    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    longest = ''
    for i in range(len(s)):
        odd_palindrome = expand_around_center(i, i)
        even_palindrome = expand_around_center(i, i + 1)
        longest = max(longest, odd_palindrome, even_palindrome, key=len)
    return longest

# 169. Find the maximum sum of a contiguous subarray (Kadane's Algorithm).
def max_subarray_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global

# 170. Generate all permutations of a given list.
from itertools import permutations
def all_permutations(lst):
    return list(permutations(lst))

# 171. Find the sum of all elements in a nested list.
def sum_nested_list(lst):
    total = 0
    for element in lst:
        if isinstance(element, list):
            total += sum_nested_list(element)
        else:
            total += element
    return total

# 172. Convert a number from one base to another.
def convert_base(num, from_base, to_base):
    decimal = int(str(num), from_base)
    return format(decimal, f'{to_base}')

# 173. Find the longest common subsequence between two strings.
def longest_common_subsequence(X, Y):
    m, n = len(X), len(Y)
    L = [[0] * (n + 1) for i in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    return L[m][n]

# 174. Implementing linked list in Python.
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def print_list(self):
        curr = self.head
        while curr:
            print(curr.data)
            curr = curr.next

# 175. Implement binary tree traversal (in-order, pre-order, post-order).
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def inorder_traversal(root):
    return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) if root else []

def preorder_traversal(root):
    return [root.value] + preorder_traversal(root.left) + preorder_traversal(root.right) if root else []

def postorder_traversal(root):
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.value] if root else []

# 176. Check if a string is a pangram.
def is_pangram(s):
    return set('abcdefghijklmnopqrstuvwxyz').issubset(set(s.lower()))

# 177. Calculate the nth Fibonacci number using dynamic programming.
def fibonacci_dp(n):
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[i-1] + fib[i-2])
    return fib[n]

# 178. Implement Caesar cipher encryption.
def caesar_cipher_encrypt(text, shift):
    result = ""
    for i in text:
        if i.isalpha():
            shift_base = ord('a') if i.islower() else ord('A')
            result += chr((ord(i) - shift_base + shift) % 26 + shift_base)
        else:
            result += i
    return result

# 179. Implement Caesar cipher decryption.
def caesar_cipher_decrypt(text, shift):
    return caesar_cipher_encrypt(text, -shift)

# 180. Find the first non-repeating character in a string.
def first_non_repeating_char(s):
    from collections import Counter
    count = Counter(s)
    for char in s:
        if count[char] == 1:
            return char
    return None

# 181. Check if two rectangles overlap.
def rectangles_overlap(r1, r2):
    return not (r1['left'] > r2['right'] or r1['right'] < r2['left'] or r1['top'] < r2['bottom'] or r1['bottom'] > r2['top'])

# 182. Calculate the Levenshtein distance between two strings.
def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    if len(s2) == 0:
        return len(s1)
    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    return previous_row[-1]

# 183. Check if a number is an Armstrong number.
def is_armstrong(number):
    num_str = str(number)
    power = len(num_str)
    return number == sum(int(digit) ** power for digit in num_str)

# 184. Find the length of the longest word in a sentence.
def longest_word_length(sentence):
    return max(len(word) for word in sentence.split())

# 185. Generate Pascal's triangle up to n rows.
def pascals_triangle(n):
    triangle = [[1]]
    for i in range(1, n):
        row = [1] + [triangle[i-1][j] + triangle[i-1][j+1] for j in range(len(triangle[i-1]) - 1)] + [1]
        triangle.append(row)
    return triangle

# 186. Calculate the transpose of a matrix.
def transpose(matrix):
    return list(map(list, zip(*matrix)))

# 187. Check if a string is a valid palindrome ignoring non-alphanumeric characters.
import re
def is_valid_palindrome(s):
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]

# 188. Rotate a matrix 90 degrees clockwise.
def rotate_matrix_90(matrix):
    return [list(row) for row in zip(*matrix[::-1])]

# 189. Convert a binary number to decimal.
def binary_to_decimal(binary):
    return int(binary, 2)

# 190. Convert a decimal number to binary.
def decimal_to_binary(decimal):
    return bin(decimal)[2:]

# 191. Flatten a nested list.
def flatten_list(nested_list):
    flat_list = []
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten_list(item))
        else:
            flat_list.append(item)
    return flat_list

# 192. Check if a given number is a power of two.
def is_power_of_two(n):
    return n > 0 and (n & (n - 1)) == 0

# 193. Merge overlapping intervals.
def merge_intervals(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            merged[-1] = [last[0], max(last[1], current[1])]
        else:
            merged.append(current)
    return merged

# 194. Find the smallest positive integer missing from an unsorted list.
def smallest_missing_positive(nums):
    nums = [num for num in nums if num > 0]
    nums_set = set(nums)
    smallest_missing = 1
    while smallest_missing in nums_set:
        smallest_missing += 1
    return smallest_missing

# 195. Implement matrix multiplication.
def matrix_multiply(A, B):
    result = [[sum(x * y for x, y in zip(A_row, B_col)) for B_col in zip(*B)] for A_row in A]
    return result

# 196. Find the longest common prefix among a list of strings.
def longest_common_prefix(strs):
    if not strs:
        return ""
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        if any(s[i] != char for s in strs):
            return shortest[:i]
    return shortest

# 197. Find the largest rectangle in a histogram.
def largest_rectangle_area(heights):
    stack, max_area = [], 0
    heights.append(0)
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            H = heights[stack.pop()]
            W = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, H * W)
        stack.append(i)
    return max_area

# 198. Implement bucket sort for floating-point numbers.
def bucket_sort_floats(arr):
    buckets = [[] for _ in range(len(arr))]
    for num in arr:
        index = int(num * len(arr))
        buckets[index].append(num)
    for i in range(len(arr)):
        buckets[i] = sorted(buckets[i])
    return [num for bucket in buckets for num in bucket]

# 199. Find the maximum product of two elements in an array.
def max_product_two_elements(arr):
    arr.sort()
    return arr[-1] * arr[-2]

# 200. Check if a string is a valid IPv4 address.
def is_valid_ipv4(ip):
    parts = ip.split(".")
    return len(parts) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in parts)

# 201. Find the majority element in an array (appears more than n/2 times).
def majority_element(arr):
    candidate, count = None, 0
    for num in arr:
        if count == 0:
            candidate, count = num, 1
        elif num == candidate:
            count += 1
        else:
            count -= 1
    return candidate if arr.count(candidate) > len(arr) // 2 else None

# 202. Check if two strings are rotations of each other.
def are_rotations(str1, str2):
    return len(str1) == len(str2) and str2 in str1 + str1

# 203. Count inversions in an array (merge sort approach).
def count_inversions(arr):
    def merge_count_split_inv(arr, temp_arr, left, right):
        if left == right:
            return 0
        mid = (left + right) // 2
        inv_count = merge_count_split_inv(arr, temp_arr, left, mid)
        inv_count += merge_count_split_inv(arr, temp_arr, mid + 1, right)
        inv_count += merge(arr, temp_arr, left, mid, right)
        return inv_count

    def merge(arr, temp_arr, left, mid, right):
        i, j, k, inv_count = left, mid + 1, left, 0
        while i <= mid and j <= right:
            if arr[i] <= arr[j]:
                temp_arr[k] = arr[i]
                i += 1
            else:
                temp_arr[k] = arr[j]
                inv_count += (mid-i + 1)
                j += 1
            k += 1
        while i <= mid:
            temp_arr[k] = arr[i]
            i += 1
            k += 1
        while j <= right:
            temp_arr[k] = arr[j]
            j += 1
            k += 1
        for i in range(left, right + 1):
            arr[i] = temp_arr[i]
        return inv_count

    return merge_count_split_inv(arr, [0]*len(arr), 0, len(arr)-1)

# 204. Implement recursive binary search.
def binary_search_recursive(arr, low, high, x):
    if high >= low:
        mid = (high + low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search_recursive(arr, low, mid - 1, x)
        else:
            return binary_search_recursive(arr, mid + 1, high, x)
    return -1

# 205. Find the intersection of two arrays.
def array_intersection(arr1, arr2):
    return list(set(arr1) & set(arr2))

# 206. Find the union of two arrays.
def array_union(arr1, arr2):
    return list(set(arr1) | set(arr2))

# 207. Implement breadth-first search (BFS) for a graph.
from collections import deque
def bfs(graph, start):
    visited, queue = set(), deque([start])
    result = []
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)
            queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)
    return result

# 208. Implement depth-first search (DFS) for a graph.
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    result = [start]
    for next_vertex in graph[start] - visited:
        result.extend(dfs(graph, next_vertex, visited))
    return result

# 209. Convert a given string to Morse code.
MORSE_CODE_DICT = {
    'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....',
    'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.',
    'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
    'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
    '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----'
}

def to_morse_code(text):
    return ' '.join(MORSE_CODE_DICT.get(char.upper(), '') for char in text)

# 210. Convert Morse code to English.
def morse_to_english(morse_code):
    inverse_morse_dict = {v: k for k, v in MORSE_CODE_DICT.items()}
    return ''.join(inverse_morse_dict.get(code, '') for code in morse_code.split())

# 211. Check if a string is a valid email address.
import re
def is_valid_email(email):
    regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(regex, email))

# 212. Check if an array is monotonic (either entirely non-increasing or non-decreasing).
def is_monotonic(arr):
    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1))

# 213. Rotate an array by k elements to the right.
def rotate_array(arr, k):
    k %= len(arr)
    return arr[-k:] + arr[:-k]

# 214. Find the minimum number of coins to make change for an amount.
def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        dp[i] = min([dp[i - coin] + 1 for coin in coins if i - coin >= 0], default=float('inf'))
    return dp[amount] if dp[amount] != float('inf') else -1

# 215. Check if a matrix is symmetric.
def is_symmetric(matrix):
    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix[i])))

# 216. Implement a priority queue using a heap.
import heapq
class PriorityQueue:
    def __init__(self):
        self.queue = []
    def push(self, item, priority):
        heapq.heappush(self.queue, (-priority, item))
    def pop(self):
        return heapq.heappop(self.queue)[1]
    def is_empty(self):
        return len(self.queue) == 0

# 217. Find the nth prime number.
def nth_prime(n):
    primes = []
    num = 2
    while len(primes) < n:
        if all(num % prime != 0 for prime in primes):
            primes.append(num)
        num += 1
    return primes[-1]

# 218. Implement a function to flatten a dictionary.
def flatten_dict(d, parent_key='', sep='_'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

# 219. Find the prime factors of a number.
def prime_factors(n):
    i, factors = 2, []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

# 220. Implement counting sort for characters (A-Z).
def counting_sort_characters(s):
    count = [0] * 26
    for char in s:
        count[ord(char) - ord('A')] += 1
    return ''.join(chr(i + ord('A')) * count[i] for i in range(26))

# 221. Generate random password of a given length.
import random
import string
def generate_password(length=8):
    characters = string.ascii_letters + string.digits + string.punctuation
    return ''.join(random.choice(characters) for _ in range(length))

# 222. Find the Hamming distance between two strings of equal length.
def hamming_distance(str1, str2):
    if len(str1) != len(str2):
        raise ValueError("Strings must be of equal length")
    return sum(1 for x, y in zip(str1, str2) if x != y)

# 223. Convert a given sentence to Pig Latin.
def to_pig_latin(sentence):
    def convert_word(word):
        return word[1:] + word[0] + 'ay' if word[0] not in 'aeiou' else word + 'way'
    return ' '.join(convert_word(word) for word in sentence.split())

# 224. Calculate the day of the week for a given date.
import datetime
def day_of_week(year, month, day):
    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    return days[datetime.date(year, month, day).weekday()]

# 225. Check if a number is a perfect square.
def is_perfect_square(num):
    return int(num ** 0.5) ** 2 == num

# 226. Implement ternary search.
def ternary_search(arr, left, right, x):
    if right >= left:
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        if arr[mid1] == x:
            return mid1
        if arr[mid2] == x:
            return mid2
        if x < arr[mid1]:
            return ternary_search(arr, left, mid1 - 1, x)
        elif x > arr[mid2]:
            return ternary_search(arr, mid2 + 1, right, x)
        else:
            return ternary_search(arr, mid1 + 1, mid2 - 1, x)
    return -1

# 227. Generate Fibonacci series up to a specified number.
def fibonacci_up_to(n):
    a, b = 0, 1
    result = []
    while a <= n:
        result.append(a)
        a, b = b, a + b
    return result

# 228. Determine if a number is part of the Fibonacci series.
def is_fibonacci_number(n):
    return is_perfect_square(5 * n ** 2 + 4) or is_perfect_square(5 * n ** 2 - 4)

# 229. Calculate the factorial of a number using iterative approach.
def factorial_iterative(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# 230. Create a list of n random numbers within a specified range.
def random_numbers(n, start, end):
    return [random.randint(start, end) for _ in range(n)]

# 231. Calculate the power of a number modulo another number.
def power_mod(base, exponent, mod):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exponent //= 2
    return result

# 232. Check if a string has all unique characters.
def all_unique_characters(s):
    return len(set(s)) == len(s)

# 233. Find the longest substring without repeating characters.
def longest_unique_substring(s):
    seen, start, max_len, longest = {}, 0, 0, ""
    for i, char in enumerate(s):
        if char in seen and start <= seen[char]:
            start = seen[char] + 1
        else:
            current_len = i - start + 1
            if current_len > max_len:
                max_len = current_len
                longest = s[start:i + 1]
        seen[char] = i
    return longest

# 234. Implement a circular doubly linked list.
class CircularDoublyLinkedListNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class CircularDoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = CircularDoublyLinkedListNode(data)
        if not self.head:
            self.head = new_node
            self.head.next = self.head
            self.head.prev = self.head
        else:
            last = self.head.prev
            last.next = new_node
            new_node.prev = last
            new_node.next = self.head
            self.head.prev = new_node

    def display(self):
        nodes, current = [], self.head
        while True:
            nodes.append(current.data)
            current = current.next
            if current == self.head:
                break
        return nodes

# 235. Find all prime numbers up to a given limit using Sieve of Eratosthenes.
def sieve_of_eratosthenes(limit):
    sieve = [True] * (limit + 1)
    p = 2
    while (p ** 2 <= limit):
        if sieve[p]:
            for i in range(p * p, limit + 1, p):
                sieve[i] = False
        p += 1
    return [p for p in range(2, limit + 1) if sieve[p]]

# 236. Find all permutations of a string.
from itertools import permutations
def string_permutations(s):
    return [''.join(p) for p in permutations(s)]

# 237. Implement a simple calculator that can add, subtract, multiply, divide.
def calculator(a, b, operation):
    if operation == 'add':
        return a + b
    elif operation == 'subtract':
        return a - b
    elif operation == 'multiply':
        return a * b
    elif operation == 'divide':
        return a / b if b != 0 else "Division by zero error"
    else:
        return "Invalid operation"

# 238. Calculate GCD using Euclid's algorithm.
def gcd_euclid(a, b):
    while b:
        a, b = b, a % b
    return a

# 239. Calculate LCM using GCD.
def lcm_using_gcd(a, b):
    return abs(a * b) // gcd_euclid(a, b)

# 240. Count the occurrence of each element in a list.
from collections import Counter
def element_counts(lst):
    return dict(Counter(lst))

# 241. Find the most common element in a list.
def most_common_element(lst):
    return max(set(lst), key=lst.count)

# 242. Check if a given number is prime using trial division.
def is_prime_trial_division(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# 243. Find all factors of a number.
def find_factors(n):
    return [i for i in range(1, n + 1) if n % i == 0]

# 244. Implement a basic Caesar cipher decrypt.
def caesar_cipher_decrypt_basic(ciphertext, shift):
    decrypted = ''
    for char in ciphertext:
        if char.isalpha():
            shift_base = ord('a') if char.islower() else ord('A')
            decrypted += chr((ord(char) - shift_base - shift) % 26 + shift_base)
        else:
            decrypted += char
    return decrypted

# 245. Convert an integer to a string with commas as thousands separators.
def int_to_commas(number):
    return f"{number:,}"

# 246. Find the greatest common divisor of a list of numbers.
from functools import reduce
def gcd_of_list(numbers):
    return reduce(gcd_euclid, numbers)

# 247. Find the smallest common multiple of a list of numbers.
def lcm_of_list(numbers):
    return reduce(lcm_using_gcd, numbers)

# 248. Implement Floyd's triangle.
def floyd_triangle(n):
    num, result = 1, []
    for i in range(1, n + 1):
        row = [num + j for j in range(i)]
        result.append(row)
        num += i
    return result

# 249. Implement a function to calculate the nth triangular number.
def triangular_number(n):
    return n * (n + 1) // 2

# 250. Calculate the area of a polygon using vertices coordinates (Shoelace formula).
def polygon_area(vertices):
    n = len(vertices)
    area = 0.0
    for i in range(n):
        x1, y1 = vertices[i]
        x2, y2 = vertices[(i + 1) % n]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2

# 251. Find the most frequent word in a sentence.
def most_frequent_word(sentence):
    words = sentence.lower().split()
    return max(set(words), key=words.count)

# 252. Find the mode(s) of a list of numbers.
def modes(lst):
    from collections import Counter
    count = Counter(lst)
    max_count = max(count.values())
    return [key for key, value in count.items() if value == max_count]

# 253. Implement a simple hash function.
def simple_hash(string, size=10):
    return sum(ord(char) for char in string) % size

# 254. Calculate the exponential moving average of a list of numbers.
def exponential_moving_average(data, alpha=0.1):
    ema = [data[0]]
    for price in data[1:]:
        ema.append(alpha * price + (1 - alpha) * ema[-1])
    return ema

# 255. Implement binary exponentiation (exponentiation by squaring).
def binary_exponentiation(base, exp):
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result *= base
        base *= base
        exp //= 2
    return result

# 256. Check if a number is a palindrome without converting to string.
def is_palindrome_number(n):
    original, reverse = n, 0
    while n > 0:
        reverse = reverse * 10 + n % 10
        n //= 10
    return original == reverse

# 257. Find the nth number in the sequence of prime numbers.
def nth_prime_number(n):
    count, num = 0, 1
    while count < n:
        num += 1
        if is_prime(num):
            count += 1
    return num

# 258. Implement a function to find GCD of two numbers using recursion.
def gcd_recursive(a, b):
    return a if b == 0 else gcd_recursive(b, a % b)

# 259. Calculate the n-th root of a number.
def nth_root(x, n):
    return x ** (1 / n)

# 260. Implement a function to convert a list to a dictionary with indices as keys.
def list_to_dict(lst):
    return {i: lst[i] for i in range(len(lst))}

# 261. Implement a function to reverse a dictionary.
def reverse_dict(d):
    return {v: k for k, v in d.items()}

# 262. Check if two lists are equal irrespective of the order of elements.
def are_lists_equal(lst1, lst2):
    return sorted(lst1) == sorted(lst2)

# 263. Find the length of the longest increasing subsequence in a list.
def longest_increasing_subsequence(lst):
    if not lst:
        return 0
    lis = [1] * len(lst)
    for i in range(1, len(lst)):
        for j in range(i):
            if lst[i] > lst[j]:
                lis[i] = max(lis[i], lis[j] + 1)
    return max(lis)

# 264. Count the number of words in a list of sentences.
def count_words_in_sentences(sentences):
    return sum(len(sentence.split()) for sentence in sentences)

# 265. Convert a list of strings to uppercase.
def uppercase_list(lst):
    return [s.upper() for s in lst]

# 266. Calculate the compound annual growth rate (CAGR).
def cagr(initial_value, final_value, years):
    return ((final_value / initial_value) ** (1 / years) - 1) * 100

# 267. Find the prime numbers within a given range.
def primes_in_range(lower, upper):
    return [num for num in range(lower, upper + 1) if is_prime(num)]

# 268. Find the minimum absolute difference between any two elements in a list.
def min_absolute_difference(lst):
    lst.sort()
    return min(abs(lst[i] - lst[i+1]) for i in range(len(lst) - 1))

# 269. Remove consecutive duplicates from a list.
def remove_consecutive_duplicates(lst):
    return [val for i, val in enumerate(lst) if i == 0 or val != lst[i - 1]]

# 270. Determine if a number is abundant, deficient, or perfect.
def classify_number(n):
    divisors_sum = sum(i for i in range(1, n) if n % i == 0)
    if divisors_sum == n:
        return 'Perfect'
    elif divisors_sum > n:
        return 'Abundant'
    else:
        return 'Deficient'

# 271. Calculate the weighted average of a list with given weights.
def weighted_average(values, weights):
    return sum(val * wt for val, wt in zip(values, weights)) / sum(weights)

# 272. Find the median of two sorted arrays.
def median_of_two_sorted_arrays(arr1, arr2):
    merged = sorted(arr1 + arr2)
    n = len(merged)
    return (merged[n // 2] + merged[(n - 1) // 2]) / 2

# 273. Calculate the determinant of a 3x3 matrix.
def determinant_3x3(matrix):
    return (matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
            - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
            + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]))

# 274. Check if a number is a power of another number.
def is_power_of(n, base):
    if n <= 0:
        return False
    while n % base == 0:
        n //= base
    return n == 1

# 275. Find all palindromic numbers within a range.
def palindromic_numbers_in_range(start, end):
    return [num for num in range(start, end + 1) if is_palindrome_number(num)]

# 276. Calculate the Jaccard similarity between two sets.
def jaccard_similarity(set1, set2):
    intersection = len(set1 & set2)
    union = len(set1 | set2)
    return intersection / union if union else 0

# 277. Convert a list of numbers to their hexadecimal representation.
def list_to_hex(lst):
    return [hex(num) for num in lst]

# 278. Generate a random color in hexadecimal format.
def random_hex_color():
    return "#{:06x}".format(random.randint(0, 0xFFFFFF))

# 279. Convert a list of words to a single string with spaces.
def list_to_sentence(words):
    return ' '.join(words)

# 280. Implement a function to reverse each word in a sentence.
def reverse_words_in_sentence(sentence):
    return ' '.join(word[::-1] for word in sentence.split())

# 281. Count the number of vowels in a list of strings.
def count_vowels_in_list(lst):
    return sum(sum(1 for char in word if char in 'aeiouAEIOU') for word in lst)

# 282. Check if a string is a valid identifier in Python.
def is_valid_identifier(s):
    return s.isidentifier()

# 283. Find the sum of all prime numbers up to a given limit.
def sum_primes_up_to(limit):
    return sum(primes_in_range(2, limit))

# 284. Find the most common character in a string.
def most_common_char(s):
    return max(set(s), key=s.count)

# 285. Replace all vowels in a string with a specified character.
def replace_vowels(s, char):
    return ''.join([char if c in 'aeiouAEIOU' else c for c in s])

# 286. Implement a function to generate a secure random token.
import secrets
def generate_secure_token(length=16):
    return secrets.token_hex(length)

# 287. Sort a list of tuples based on the second element in each tuple.
def sort_by_second_element(tuples_list):
    return sorted(tuples_list, key=lambda x: x[1])

# 288. Count the number of consonants in a string.
def count_consonants(s):
    return sum(1 for char in s.lower() if char.isalpha() and char not in 'aeiou')

# 289. Implement a function to convert binary string to decimal.
def binary_string_to_decimal(binary_string):
    return int(binary_string, 2)

# 290. Calculate the harmonic mean of a list of numbers.
from scipy.stats import hmean

def harmonic_mean(numbers):
    return hmean(numbers)
